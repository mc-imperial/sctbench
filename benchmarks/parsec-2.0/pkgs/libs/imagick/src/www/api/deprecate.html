<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<head>
  <style type="text/css" media="screen,projection"><!--
    @import url("../../www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/www/magick.css");
  //--></style>
  <title>ImageMagick: MagickCore, C API for ImageMagick: Deprecated Methods</title>
  <meta http-equiv="Content-Language" content="en-US"/>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta http-equiv="Reply-to" content="magick-users@imagemagick.org"/>
  <meta name="Generator" content="PHP"/>
  <meta name="Keywords" content="magickcore, c, api, for, imagemagick:, deprecated, methods, ImageMagick, ImageMagic, MagickCore, MagickWand, PerlMagick, Magick++, RMagick, PythonMagick, JMagick, TclMagick, Image, Magick, Magic, Wand"/>
  <meta name="Description" content="ImageMagick® is a software suite to create, edit, and compose bitmap images. It can read, convert and write images in a variety of formats (about 100) including GIF, JPEG, JPEG-2000, PNG, PDF, PhotoCD, TIFF, and DPX. Use ImageMagick to translate, flip, mirror, rotate, scale, shear and transform images, adjust image colors, apply various special effects, or draw text, lines, polygons, ellipses and Bézier curves.  ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you can freely use, copy, modify, and distribute. Its license is compatible with the GPL. It runs on all major operating systems.  The functionality of ImageMagick is typically utilized from the command line or you can use the features from programs written in your favorite programming language. Choose from these interfaces: MagickCore (C), MagickWand (C), ChMagick (Ch), Magick++ (C++), JMagick (Java), L-Magick (Lisp), PascalMagick (Pascal), PerlMagick (Perl), MagickWand for PHP (PHP), PythonMagick (Python), RMagick (Ruby), or TclMagick (Tcl/TK). With a language interface, use ImageMagick to modify or create images automagically and dynamically."/>
  <meta name="Rating" content="GENERAL"/>
  <meta name="Robots" content="INDEX, FOLLOW"/>
  <meta name="Generator" content="ImageMagick Studio LLC"/>
  <meta name="Author" content="ImageMagick Studio LLC"/>
  <meta name="Revisit-after" content="2 DAYS"/>
  <meta name="Resource-type" content="document"/>
  <meta name="Copyright" content="Copyright (c) 1999-2007 ImageMagick Studio LLC"/>
  <meta name="Distribution" content="Global"/>
  <link rel="shortcut icon" href="../../images/wand.ico"  type="images/vnd.microsoft.icon"/>
</head>

<body id="www-imagemagick-org">
  <table id="titlebar" style="width: 100%;background-color: #f5f5f5" cellpadding="0" cellspacing="0" border="0" summary="ImageMagick">
    <tbody>
      <tr valign="top">
        <td align="left"><a href="../../index.html"><img id="titlebar-west" src="../../images/script.png" alt="[ImageMagick]" width="350" height="60" border="0" vspace="28" name="titlebar-west"/></a></td>
        <td align="left"><a href="https://secure.networkredux.com/affiliate/idevaffiliate.html?id=146" target="1281987714"><img id="titlebar-west" src="../../images/networkredux.png" alt="[sponsor]" border="0" vspace="45" name="titlebar-west"/></a></td>
        <td width="99%"><br /></td>
        <td style="background-color: white" align="right"><a href="../../index.html"><img src="../../images/sprite.jpg" alt="" width="114" height="118" border="0" name="titlebar-east"/></a></td>
        <td style="background-color: white" align="right"><a href="../../index.html"><img id="titlebar-east" src="../../images/logo.jpg" alt="" width="114" height="118" border="0" name="titlebar-east"/></a></td>
      </tr>
    </tbody>
  </table>

  <table style="width: 100%" border="0" cellpadding="0" cellspacing="0" summary="">
  <tbody>

    <tr valign="top" style="height: 100%;">
      <td id="menu" width="1%" height="100%">
      <p><a href="#main">Skip to page contents</a></p>
      <span>[</span>
      <a href="../../index.html">About ImageMagick</a>
      <a href="../../www/command-line-tools.html">Command-line Tools</a>
      <a href="../../www/command-line-processing.html" class="sub">Processing</a>
      <a href="../../www/command-line-options.html" class="sub">Options</a>
      <a href="../../www/api.html">Program Interfaces</a>
      <a href="../../www/magick-wand.html" class="sub">MagickWand</a>
      <a href="../../www/magick-core.html" class="sub">MagickCore</a>
      <a href="../../www/perl-magick.html" class="sub">PerlMagick</a>
      <a href="../../www/architecture.html">Architecture</a>
  <span>]</span><br /><span>[</span>
      <a href="../../www/install-source.html">Install from Source</a>
      <a href="../../www/install-source.html#unix" class="sub">Unix</a>
      <a href="../../www/install-source.html#windows" class="sub">Windows</a>
      <a href="../../www/binary-releases.html">Binary Releases</a>
      <a href="../../www/binary-releases.html#unix" class="sub">Unix</a>
      <a href="../../www/binary-releases.html#macosx" class="sub">Mac OS X</a>
      <a href="../../www/binary-releases.html#windows" class="sub">Windows</a>
      <a href="../../www/resources.html">Resources</a>
  <span>]</span><br /><span>[</span>
      <a href="../../www/download.html">Download</a>
  <span>]</span><br /><span>[</span>
      <a href="../../www/sitemap.html">Site Map</a>
			<a href="../../www/links.html" class="sub">Links</a>
  <span>]</span><br /><br /><span>[</span>
      <a href="../../www/sponsors.html">Sponsors</a>
  <a href="http://urltra.de/" class="sponsor" target="sponsor">Linkliste URLtra</a><!-- 200711120050 -->
      <span>]</span>
      </td>

      <td id="main" valign="top">
<p class="navigation-index">[ <a href="#AcquireMemory">AcquireMemory</a> | <a href="#AllocateString">AllocateString</a> | <a href="#ChannelThresholdImage">ChannelThresholdImage</a> | <a href="#CloneImageAttributes">CloneImageAttributes</a> | <a href="#CloneMemory">CloneMemory</a> | <a href="#ColorFloodfill">ColorFloodfill</a> | <a href="#DeleteImageAttribute">DeleteImageAttribute</a> | <a href="#DeleteImageList">DeleteImageList</a> | <a href="#DescribeImage">DescribeImage</a> | <a href="#DestroyImageAttributes">DestroyImageAttributes</a> | <a href="#DestroyImages">DestroyImages</a> | <a href="#DestroyMagick">DestroyMagick</a> | <a href="#DispatchImage">DispatchImage</a> | <a href="#FormatImageAttribute">FormatImageAttribute</a> | <a href="#FormatString">FormatString</a> | <a href="#GetConfigureBlob">GetConfigureBlob</a> | <a href="#GetImageAttribute">GetImageAttribute</a> | <a href="#GetImageClippingPathAttribute">GetImageClippingPathAttribute</a> | <a href="#GetImageGeometry">GetImageGeometry</a> | <a href="#GetImageList">GetImageList</a> | <a href="#GetImageListIndex">GetImageListIndex</a> | <a href="#GetImageListSize">GetImageListSize</a> | <a href="#GetNextImage">GetNextImage</a> | <a href="#GetNextImageAttribute">GetNextImageAttribute</a> | <a href="#GetNumberScenes">GetNumberScenes</a> | <a href="#GetPreviousImage">GetPreviousImage</a> | <a href="#IdentityAffine">IdentityAffine</a> | <a href="#InitializeMagick">InitializeMagick</a> | <a href="#InterpretImageAttributes">InterpretImageAttributes</a> | <a href="#LiberateMemory">LiberateMemory</a> | <a href="#LiberateSemaphoreInfo">LiberateSemaphoreInfo</a> | <a href="#MagickIncarnate">MagickIncarnate</a> | <a href="#MagickMonitor">MagickMonitor</a> | <a href="#MatteFloodfill">MatteFloodfill</a> | <a href="#OpaqueImage">OpaqueImage</a> | <a href="#PopImageList">PopImageList</a> | <a href="#PopImagePixels">PopImagePixels</a> | <a href="#PostscriptGeometry">PostscriptGeometry</a> | <a href="#PushImageList">PushImageList</a> | <a href="#PushImagePixels">PushImagePixels</a> | <a href="#QuantizationError">QuantizationError</a> | <a href="#RandomChannelThresholdImage">RandomChannelThresholdImage</a> | <a href="#ReacquireMemory">ReacquireMemory</a> | <a href="#ResetImageAttributeIterator">ResetImageAttributeIterator</a> | <a href="#SetExceptionInfo">SetExceptionInfo</a> | <a href="#SetImage">SetImage</a> | <a href="#SetImageAttribute">SetImageAttribute</a> | <a href="#SetImageList">SetImageList</a> | <a href="#SetMonitorHandler">SetMonitorHandler</a> | <a href="#ShiftImageList">ShiftImageList</a> | <a href="#SpliceImageList">SpliceImageList</a> | <a href="#Strip">Strip</a> | <a href="#TemporaryFilename">TemporaryFilename</a> | <a href="#ThresholdImage">ThresholdImage</a> | <a href="#ThresholdImageChannel">ThresholdImageChannel</a> | <a href="#TranslateText">TranslateText</a> | <a href="#TransparentImage">TransparentImage</a> | <a href="#UnshiftImageList">UnshiftImageList</a> ]</p>

<div style="margin: auto;">
  <h2><a name="AcquireMemory">AcquireMemory</a></h2>
</div>

<p>AcquireMemory() returns a pointer to a block of memory at least size bytes suitably aligned for any use.</p></ol>

<p>The format of the AcquireMemory method is:</p>

<pre class="code">
  void *AcquireMemory(const size_t size)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>size</h5>
<ol><p>The size of the memory in bytes to allocate.</p></ol>

<div style="margin: auto;">
  <h2><a name="AllocateString">AllocateString</a></h2>
</div>

<p>AllocateString() allocates memory for a string and copies the source string to that memory location (and returns it).</p></ol>

<p>The format of the AllocateString method is:</p>

<pre class="code">
  char *AllocateString(const char *source)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>source</h5>
<ol><p>A character string.</p></ol>

<div style="margin: auto;">
  <h2><a name="ChannelThresholdImage">ChannelThresholdImage</a></h2>
</div>

<p>ChannelThresholdImage() changes the value of individual pixels based on the intensity of each pixel channel.  The result is a high-contrast image.</p></ol>

<p>The format of the ChannelThresholdImage method is:</p>

<pre class="code">
  unsigned int ChannelThresholdImage(Image *image,const char *level)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>level</h5>
<ol><p>define the threshold values.</p></ol>

<div style="margin: auto;">
  <h2><a name="CloneImageAttributes">CloneImageAttributes</a></h2>
</div>

<p>CloneImageAttributes() clones one or more image attributes.</p></ol>

<p>The format of the CloneImageAttributes method is:</p>

<pre class="code">
  MagickBooleanType CloneImageAttributes(Image *image,
    const Image *clone_image)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>clone_image</h5>
<ol><p>The clone image.</p></ol>

<div style="margin: auto;">
  <h2><a name="CloneMemory">CloneMemory</a></h2>
</div>

<p>CloneMemory() copies size bytes from memory area source to the destination. Copying between objects that overlap will take place correctly.  It returns destination.</p></ol>

<p>The format of the CloneMemory method is:</p>

<pre class="code">
  void *CloneMemory(void *destination,const void *source,
    const size_t size)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>destination</h5>
<ol><p>The destination.</p></ol>

<h5>source</h5>
<ol><p>The source.</p></ol>

<h5>size</h5>
<ol><p>The size of the memory in bytes to allocate.</p></ol>

<div style="margin: auto;">
  <h2><a name="ColorFloodfill">ColorFloodfill</a></h2>
</div>

<p>ColorFloodfill() changes the color value of any pixel that matches target and is an immediate neighbor.  If the method FillToBorderMethod is specified, the color value is changed for any neighbor pixel that does not match the bordercolor member of image.</p></ol>

<p>By default target must match a particular pixel color exactly. However, in many cases two colors may differ by a small amount.  The fuzz member of image defines how much tolerance is acceptable to consider two colors as the same.  For example, set fuzz to 10 and the color red at intensities of 100 and 102 respectively are now interpreted as the same color for the purposes of the floodfill.</p></ol>

<p>The format of the ColorFloodfillImage method is:</p>

<pre class="code">
  MagickBooleanType ColorFloodfillImage(Image *image,
    const DrawInfo *draw_info,const PixelPacket target,
    const long x_offset,const long y_offset,const PaintMethod method)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>draw_info</h5>
<ol><p>The draw info.</p></ol>

<h5>target</h5>
<ol><p>The RGB value of the target color.</p></ol>

<h5>x,y</h5>
<ol><p>The starting location of the operation.</p></ol>

<h5>method</h5>
<ol><p>Choose either FloodfillMethod or FillToBorderMethod.</p></ol>

<div style="margin: auto;">
  <h2><a name="DeleteImageAttribute">DeleteImageAttribute</a></h2>
</div>

<p>DeleteImageAttribute() deletes an attribute from the image.</p></ol>

<p>The format of the DeleteImageAttribute method is:</p>

<pre class="code">
  MagickBooleanType DeleteImageAttribute(Image *image,const char *key)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image info.</p></ol>

<h5>key</h5>
<ol><p>The image key.</p></ol>

<div style="margin: auto;">
  <h2><a name="DeleteImageList">DeleteImageList</a></h2>
</div>

<p>DeleteImageList() deletes an image at the specified position in the list.</p></ol>

<p>The format of the DeleteImageList method is:</p>

<pre class="code">
  unsigned int DeleteImageList(Image *images,const long offset)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<h5>offset</h5>
<ol><p>The position within the list.</p></ol>

<div style="margin: auto;">
  <h2><a name="DescribeImage">DescribeImage</a></h2>
</div>

<p>DescribeImage() describes an image by printing its attributes to the file. Attributes include the image width, height, size, and others.</p></ol>

<p>The format of the DescribeImage method is:</p>

<pre class="code">
  MagickBooleanType DescribeImage(Image *image,FILE *file,
    const MagickBooleanType verbose)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>file</h5>
<ol><p>The file, typically stdout.</p></ol>

<h5>verbose</h5>
<ol><p>A value other than zero prints more detailed information about the image.</p></ol>

<div style="margin: auto;">
  <h2><a name="DestroyImageAttributes">DestroyImageAttributes</a></h2>
</div>

<p>DestroyImageAttributes() deallocates memory associated with the image attribute list.</p></ol>

<p>The format of the DestroyImageAttributes method is:</p>

<pre class="code">
  DestroyImageAttributes(Image *image)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<div style="margin: auto;">
  <h2><a name="DestroyImages">DestroyImages</a></h2>
</div>

<p>DestroyImages() destroys an image list.</p></ol>

<p>The format of the DestroyImages method is:</p>

<pre class="code">
  void DestroyImages(Image *image)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image sequence.</p></ol>

<div style="margin: auto;">
  <h2><a name="DestroyMagick">DestroyMagick</a></h2>
</div>

<p>DestroyMagick() destroys the ImageMagick environment.</p></ol>

<p>The format of the DestroyMagick function is:</p>

<pre class="text">
  DestroyMagick(void)
</pre>

<div style="margin: auto;">
  <h2><a name="DispatchImage">DispatchImage</a></h2>
</div>

<p>DispatchImage() extracts pixel data from an image and returns it to you. The method returns MagickFalse on success otherwise MagickTrue if an error is encountered.  The data is returned as char, short int, int, long, float, or double in the order specified by map.</p></ol>

<p>Suppose you want to extract the first scanline of a 640x480 image as character data in red-green-blue order:</p>

<pre class="text">
  DispatchImage(image,0,0,640,1,"RGB",CharPixel,pixels,exception);
</pre>

<p>The format of the DispatchImage method is:</p>

<pre class="code">
  unsigned int DispatchImage(const Image *image,const long x_offset,
    const long y_offset,const unsigned long columns,
    const unsigned long rows,const char *map,const StorageType type,
    void *pixels,ExceptionInfo *exception)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>x_offset, y_offset, columns, rows</h5>
<ol><p>These values define the perimeter of a region of pixels you want to extract.</p></ol>

<h5>map</h5>
<ol><p>This string reflects the expected ordering of the pixel array. It can be any combination or order of R = red, G = green, B = blue, A = alpha, C = cyan, Y = yellow, M = magenta, K = black, or I = intensity (for grayscale).</p></ol>

<h5>type</h5>
<ol><p>Define the data type of the pixels.  Float and double types are normalized to [0..1] otherwise [0..QuantumRange].  Choose from these types: CharPixel, ShortPixel, IntegerPixel, LongPixel, FloatPixel, or DoublePixel.</p></ol>

<h5>pixels</h5>
<ol><p>This array of values contain the pixel components as defined by map and type.  You must preallocate this array where the expected length varies depending on the values of width, height, map, and type.</p></ol>

<h5>exception</h5>
<ol><p>Return any errors or warnings in this structure.</p></ol>

<div style="margin: auto;">
  <h2><a name="FormatImageAttribute">FormatImageAttribute</a></h2>
</div>

<p>FormatImageAttribute() permits formatted key/value pairs to be saved as an image attribute.</p></ol>

<p>The format of the FormatImageAttribute method is:</p>

<pre class="code">
  MagickBooleanType FormatImageAttribute(Image *image,const char *key,
    const char *format,...)
</pre>

<p>A description of each parameter follows.</p></ol>

<h5> image</h5>
<ol><p>The image.</p></ol>

<h5> key</h5>
<ol><p>The attribute key.</p></ol>

<h5> format</h5>
<ol><p>A string describing the format to use to write the remaining arguments.</p></ol>

<div style="margin: auto;">
  <h2><a name="FormatString">FormatString</a></h2>
</div>

<p>FormatString() prints formatted output of a variable argument list.</p></ol>

<p>The format of the FormatString method is:</p>

<pre class="code">
  void FormatString(char *string,const char *format,...)
</pre>

<p>A description of each parameter follows.</p></ol>

<h5> string</h5>
<ol><p>Method FormatString returns the formatted string in this character buffer.</p></ol>

<h5> format</h5>
<ol><p>A string describing the format to use to write the remaining arguments.</p></ol>

<div style="margin: auto;">
  <h2><a name="GetConfigureBlob">GetConfigureBlob</a></h2>
</div>

<p>GetConfigureBlob() returns the specified configure file as a blob.</p></ol>

<p>The format of the GetConfigureBlob method is:</p>

<pre class="code">
  void *GetConfigureBlob(const char *filename,ExceptionInfo *exception)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>filename</h5>
<ol><p>The configure file name.</p></ol>

<h5>path</h5>
<ol><p>return the full path information of the configure file.</p></ol>

<h5>length</h5>
<ol><p>This pointer to a size_t integer sets the initial length of the blob.  On return, it reflects the actual length of the blob.</p></ol>

<h5>exception</h5>
<ol><p>Return any errors or warnings in this structure.</p></ol>

<div style="margin: auto;">
  <h2><a name="GetImageAttribute">GetImageAttribute</a></h2>
</div>

<p>GetImageAttribute() searches the list of image attributes and returns a pointer to the attribute if it exists otherwise NULL.</p></ol>

<p>The format of the GetImageAttribute method is:</p>

<pre class="code">
  const ImageAttribute *GetImageAttribute(const Image *image,
    const char *key)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>key</h5>
<ol><p>These character strings are the name of an image attribute to return.</p></ol>

<div style="margin: auto;">
  <h2><a name="GetImageClippingPathAttribute">GetImageClippingPathAttribute</a></h2>
</div>

<p>GetImageClippingPathAttribute() searches the list of image attributes and returns a pointer to a clipping path if it exists otherwise NULL.</p></ol>

<p>The format of the GetImageClippingPathAttribute method is:</p>

<pre class="code">
  const ImageAttribute *GetImageClippingPathAttribute(Image *image)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>attribute</h5>
<ol><p>Method GetImageClippingPathAttribute returns the clipping path if it exists otherwise NULL.</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<div style="margin: auto;">
  <h2><a name="GetImageGeometry">GetImageGeometry</a></h2>
</div>

<p>GetImageGeometry() returns a region as defined by the geometry string with respect to the image and its gravity.</p></ol>

<p>The format of the GetImageGeometry method is:</p>

<pre class="code">
  int GetImageGeometry(Image *image,const char *geometry,
    const unsigned int size_to_fit,RectangeInfo *region_info)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>flags</h5>
<ol><p>Method GetImageGeometry returns a bitmask that indicates which of the four values were located in the geometry string.</p></ol>

<h5>geometry</h5>
<ol><p>The geometry (e.g. 100x100+10+10).</p></ol>

<h5>size_to_fit</h5>
<ol><p>A value other than 0 means to scale the region so it fits within the specified width and height.</p></ol>

<h5>region_info</h5>
<ol><p>The region as defined by the geometry string with respect to the image and its gravity.</p></ol>

<div style="margin: auto;">
  <h2><a name="GetImageList">GetImageList</a></h2>
</div>

<p>GetImageList() returns an image at the specified position in the list.</p></ol>

<p>The format of the GetImageList method is:</p>

<pre class="code">
  Image *GetImageList(const Image *images,const long offset,
    ExceptionInfo *exception)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<h5>offset</h5>
<ol><p>The position within the list.</p></ol>

<h5>exception</h5>
<ol><p>Return any errors or warnings in this structure.</p></ol>

<div style="margin: auto;">
  <h2><a name="GetImageListIndex">GetImageListIndex</a></h2>
</div>

<p>GetImageListIndex() returns the position in the list of the specified image.</p></ol>

<p>The format of the GetImageListIndex method is:</p>

<pre class="code">
  long GetImageListIndex(const Image *images)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<div style="margin: auto;">
  <h2><a name="GetImageListSize">GetImageListSize</a></h2>
</div>

<p>GetImageListSize() returns the number of images in the list.</p></ol>

<p>The format of the GetImageListSize method is:</p>

<pre class="code">
  unsigned long GetImageListSize(const Image *images)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<div style="margin: auto;">
  <h2><a name="GetNextImage">GetNextImage</a></h2>
</div>

<p>GetNextImage() returns the next image in a list.</p></ol>

<p>The format of the GetNextImage method is:</p>

<pre class="code">
  Image *GetNextImage(const Image *images)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<div style="margin: auto;">
  <h2><a name="GetNextImageAttribute">GetNextImageAttribute</a></h2>
</div>

<p>GetNextImageAttribute() gets the next image attribute.</p></ol>

<p>The format of the GetNextImageAttribute method is:</p>

<pre class="code">
  const ImageAttribute *GetNextImageAttribute(const Image *image)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<div style="margin: auto;">
  <h2><a name="GetNumberScenes">GetNumberScenes</a></h2>
</div>

<p>GetNumberScenes() returns the number of images in the list.</p></ol>

<p>The format of the GetNumberScenes method is:</p>

<pre class="code">
  unsigned int GetNumberScenes(const Image *images)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<div style="margin: auto;">
  <h2><a name="GetPreviousImage">GetPreviousImage</a></h2>
</div>

<p>GetPreviousImage() returns the previous image in a list.</p></ol>

<p>The format of the GetPreviousImage method is:</p>

<pre class="code">
  Image *GetPreviousImage(const Image *images)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<div style="margin: auto;">
  <h2><a name="IdentityAffine">IdentityAffine</a></h2>
</div>

<p>IdentityAffine() initializes the affine transform to the identity matrix.</p></ol>

<p>The format of the IdentityAffine method is:</p>

<pre class="code">
  IdentityAffine(AffineMatrix *affine)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>affine</h5>
<ol><p>A pointer the the affine transform of type AffineMatrix.</p></ol>

<div style="margin: auto;">
  <h2><a name="InitializeMagick">InitializeMagick</a></h2>
</div>

<p>InitializeMagick() initializes the ImageMagick environment.</p></ol>

<p>The format of the InitializeMagick function is:</p>

<pre class="text">
  InitializeMagick(const char *path)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>path</h5>
<ol><p>The execution path of the current ImageMagick client.</p></ol>

<div style="margin: auto;">
  <h2><a name="InterpretImageAttributes">InterpretImageAttributes</a></h2>
</div>

<p>InterpretImageAttributes() replaces any embedded formatting characters with the appropriate image attribute and returns the translated text.</p></ol>

<p>The format of the InterpretImageAttributes method is:</p>

<pre class="code">
  char *InterpretImageAttributes(const ImageInfo *image_info,Image *image,
    const char *embed_text)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image_info</h5>
<ol><p>The image info.</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>embed_text</h5>
<ol><p>The address of a character string containing the embedded formatting characters.</p></ol>

<div style="margin: auto;">
  <h2><a name="LiberateMemory">LiberateMemory</a></h2>
</div>

<p>LiberateMemory() frees memory that has already been allocated, and NULL's the pointer to it.</p></ol>

<p>The format of the LiberateMemory method is:</p>

<pre class="code">
  void LiberateMemory(void **memory)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>memory</h5>
<ol><p>A pointer to a block of memory to free for reuse.</p></ol>

<div style="margin: auto;">
  <h2><a name="LiberateSemaphoreInfo">LiberateSemaphoreInfo</a></h2>
</div>

<p>LiberateSemaphoreInfo() relinquishes a semaphore.</p></ol>

<p>The format of the LiberateSemaphoreInfo method is:</p>

<pre class="code">
  LiberateSemaphoreInfo(void **semaphore_info)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>semaphore_info</h5>
<ol><p>Specifies a pointer to an SemaphoreInfo structure.</p></ol>

<div style="margin: auto;">
  <h2><a name="MagickIncarnate">MagickIncarnate</a></h2>
</div>

<p>MagickIncarnate() initializes the ImageMagick environment.</p></ol>

<p>The format of the MagickIncarnate function is:</p>

<pre class="text">
  MagickIncarnate(const char *path)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>path</h5>
<ol><p>The execution path of the current ImageMagick client.</p></ol>

<div style="margin: auto;">
  <h2><a name="MagickMonitor">MagickMonitor</a></h2>
</div>

<p>MagickMonitor() calls the monitor handler method with a text string that describes the task and a measure of completion.  The method returns MagickTrue on success otherwise MagickFalse if an error is encountered, e.g. if there was a user interrupt.</p></ol>

<p>The format of the MagickMonitor method is:</p>

<pre class="code">
  MagickBooleanType MagickMonitor(const char *text,
    const MagickOffsetType offset,const MagickSizeType span,
    void *client_data)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>offset</h5>
<ol><p>The position relative to the span parameter which represents how much progress has been made toward completing a task.</p></ol>

<h5>span</h5>
<ol><p>The span relative to completing a task.</p></ol>

<h5>client_data</h5>
<ol><p>The client data.</p></ol>

<div style="margin: auto;">
  <h2><a name="MatteFloodfill">MatteFloodfill</a></h2>
</div>

<p>MatteFloodfill() changes the transparency value of any pixel that matches target and is an immediate neighbor.  If the method FillToBorderMethod is specified, the transparency value is changed for any neighbor pixel that does not match the bordercolor member of image.</p></ol>

<p>By default target must match a particular pixel transparency exactly. However, in many cases two transparency values may differ by a small amount.  The fuzz member of image defines how much tolerance is acceptable to consider two transparency values as the same.  For example, set fuzz to 10 and the opacity values of 100 and 102 respectively are now interpreted as the same value for the purposes of the floodfill.</p></ol>

<p>The format of the MatteFloodfillImage method is:</p>

<pre class="code">
  MagickBooleanType MatteFloodfillImage(Image *image,
    const PixelPacket target,const Quantum opacity,const long x_offset,
    const long y_offset,const PaintMethod method)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>target</h5>
<ol><p>The RGB value of the target color.</p></ol>

<h5>opacity</h5>
<ol><p>The level of transparency: 0 is fully opaque and QuantumRange is fully transparent.</p></ol>

<h5>x,y</h5>
<ol><p>The starting location of the operation.</p></ol>

<h5>method</h5>
<ol><p>Choose either FloodfillMethod or FillToBorderMethod.</p></ol>

<div style="margin: auto;">
  <h2><a name="OpaqueImage">OpaqueImage</a></h2>
</div>

<p>OpaqueImage() changes any pixel that matches color with the color defined by fill.</p></ol>

<p>By default color must match a particular pixel color exactly.  However, in many cases two colors may differ by a small amount.  Fuzz defines how much tolerance is acceptable to consider two colors as the same. For example, set fuzz to 10 and the color red at intensities of 100 and 102 respectively are now interpreted as the same color.</p></ol>

<p>The format of the OpaqueImage method is:</p>

<pre class="code">
  MagickBooleanType OpaqueImage(Image *image,
    const PixelPacket *target,const PixelPacket fill)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>target</h5>
<ol><p>The RGB value of the target color.</p></ol>

<h5>fill</h5>
<ol><p>The replacement color.</p></ol>

<div style="margin: auto;">
  <h2><a name="PopImageList">PopImageList</a></h2>
</div>

<p>PopImageList() removes the last image in the list.</p></ol>

<p>The format of the PopImageList method is:</p>

<pre class="code">
  Image *PopImageList(Image **images)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<div style="margin: auto;">
  <h2><a name="PopImagePixels">PopImagePixels</a></h2>
</div>

<p>PopImagePixels() transfers one or more pixel components from the image pixel cache to a user supplied buffer.  The pixels are returned in network byte order.  MagickTrue is returned if the pixels are successfully transferred, otherwise MagickFalse.</p></ol>

<p>The format of the PopImagePixels method is:</p>

<pre class="code">
  MagickBooleanType PopImagePixels(Image *,const QuantumType quantum,
    unsigned char *destination)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>quantum</h5>
<ol><p>Declare which pixel components to transfer (RGB, RGBA, etc).</p></ol>

<h5>destination</h5>
<ol><p>The components are transferred to this buffer.</p></ol>

<div style="margin: auto;">
  <h2><a name="PostscriptGeometry">PostscriptGeometry</a></h2>
</div>

<p>PostscriptGeometry() replaces any page mneumonic with the equivalent size in picas.</p></ol>

<p>The format of the PostscriptGeometry method is:</p>

<pre class="code">
  char *PostscriptGeometry(const char *page)
</pre>

<p>A description of each parameter follows.</p></ol>

<h5> page</h5>
<ol><p>Specifies a pointer to an array of characters. The string is either a Postscript page name (e.g. A4) or a postscript page geometry (e.g. 612x792+36+36).</p></ol>

<div style="margin: auto;">
  <h2><a name="PushImageList">PushImageList</a></h2>
</div>

<p>PushImageList() adds an image to the end of the list.</p></ol>

<p>The format of the PushImageList method is:</p>

<pre class="code">
  unsigned int PushImageList(Image *images,const Image *image,
    ExceptionInfo *exception)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>exception</h5>
<ol><p>Return any errors or warnings in this structure.</p></ol>

<div style="margin: auto;">
  <h2><a name="PushImagePixels">PushImagePixels</a></h2>
</div>

<p>PushImagePixels() transfers one or more pixel components from a user supplied buffer into the image pixel cache of an image.  The pixels are expected in network byte order.  It returns MagickTrue if the pixels are successfully transferred, otherwise MagickFalse.</p></ol>

<p>The format of the PushImagePixels method is:</p>

<pre class="code">
  MagickBooleanType PushImagePixels(Image *image,const QuantumType quantum,
    const unsigned char *source)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>quantum</h5>
<ol><p>Declare which pixel components to transfer (red, green, blue, opacity, RGB, or RGBA).</p></ol>

<h5>source</h5>
<ol><p>The pixel components are transferred from this buffer.</p></ol>

<div style="margin: auto;">
  <h2><a name="QuantizationError">QuantizationError</a></h2>
</div>

<p>QuantizationError() measures the difference between the original and quantized images.  This difference is the total quantization error.  The error is computed by summing over all pixels in an image the distance squared in RGB space between each reference pixel value and its quantized value.  These values are computed:</p>

<pre class="text">
      o mean_error_per_pixel:  This value is the mean error for any single
  pixel in the image.
</pre>

<h5>normalized_mean_square_error</h5>
<ol><p>This value is the normalized mean quantization error for any single pixel in the image.  This distance measure is normalized to a range between 0 and 1.  It is independent of the range of red, green, and blue values in the image.</p></ol>

<h5>normalized_maximum_square_error</h5>
<ol><p>Thsi value is the normalized maximum quantization error for any single pixel in the image.  This distance measure is normalized to a range between 0 and 1.  It is independent of the range of red, green, and blue values in your image.</p></ol>


<p>The format of the QuantizationError method is:</p>

<pre class="code">
  unsigned int QuantizationError(Image *image)
</pre>

<p>A description of each parameter follows.</p></ol>

<h5>image</h5>
<ol><p>Specifies a pointer to an Image structure;  returned from ReadImage.</p></ol>

<div style="margin: auto;">
  <h2><a name="RandomChannelThresholdImage">RandomChannelThresholdImage</a></h2>
</div>

<p>RandomChannelThresholdImage() changes the value of individual pixels based on the intensity of each pixel compared to a random threshold.  The result is a low-contrast, two color image.</p></ol>

<p>The format of the RandomChannelThresholdImage method is:</p>

<pre class="code">
  unsigned int RandomChannelThresholdImage(Image *image,
     const char *channel, const char *thresholds,
     ExceptionInfo *exception)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>channel</h5>
<ol><p>The channel or channels to be thresholded.</p></ol>

<h5>thresholds</h5>
<ol><p>a geometry string containing LOWxHIGH thresholds. If the string contains 2x2, 3x3, or 4x4, then an ordered dither of order 2, 3, or 4 will be performed instead.</p></ol>

<h5>exception</h5>
<ol><p>Return any errors or warnings in this structure.</p></ol>

<div style="margin: auto;">
  <h2><a name="ReacquireMemory">ReacquireMemory</a></h2>
</div>

<p>ReacquireMemory() changes the size of the memory and returns a pointer to the (possibly moved) block.  The contents will be unchanged up to the lesser of the new and old sizes.</p></ol>

<p>The format of the ReacquireMemory method is:</p>

<pre class="code">
  void ReacquireMemory(void **memory,const size_t size)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>memory</h5>
<ol><p>A pointer to a memory allocation.  On return the pointer may change but the contents of the original allocation will not.</p></ol>

<h5>size</h5>
<ol><p>The new size of the allocated memory.</p></ol>

<div style="margin: auto;">
  <h2><a name="ResetImageAttributeIterator">ResetImageAttributeIterator</a></h2>
</div>

<p>ResetImageAttributeIterator() resets the image attributes iterator.  Use it in conjunction with GetNextImageAttribute() to iterate over all the values associated with an image.</p></ol>

<p>The format of the ResetImageAttributeIterator method is:</p>

<pre class="code">
  ResetImageAttributeIterator(const ImageInfo *image)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<div style="margin: auto;">
  <h2><a name="SetExceptionInfo">SetExceptionInfo</a></h2>
</div>

<p>SetExceptionInfo() sets the exception severity.</p></ol>

<p>The format of the SetExceptionInfo method is:</p>

<pre class="code">
  MagickBooleanType SetExceptionInfo(ExceptionInfo *exception,
    ExceptionType severity)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>exception</h5>
<ol><p>The exception info.</p></ol>

<h5>severity</h5>
<ol><p>The exception severity.</p></ol>

<div style="margin: auto;">
  <h2><a name="SetImage">SetImage</a></h2>
</div>

<p>SetImage() sets the red, green, and blue components of each pixel to the image background color and the opacity component to the specified level of transparency.  The background color is defined by the background_color member of the image.</p></ol>

<p>The format of the SetImage method is:</p>

<pre class="code">
  void SetImage(Image *image,const Quantum opacity)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>opacity</h5>
<ol><p>Set each pixel to this level of transparency.</p></ol>

<div style="margin: auto;">
  <h2><a name="SetImageAttribute">SetImageAttribute</a></h2>
</div>

<p>SetImageAttribute() searches the list of image attributes and replaces the attribute value.  If it is not found in the list, the attribute name and value is added to the list.   </p></ol>

<p>The format of the SetImageAttribute method is:</p>

<pre class="code">
   MagickBooleanType SetImageAttribute(Image *image,const char *key,
     const char *value)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>key</h5>
<ol><p>The key.</p></ol>

<h5>value</h5>
<ol><p>The value.</p></ol>

<div style="margin: auto;">
  <h2><a name="SetImageList">SetImageList</a></h2>
</div>

<p>SetImageList() inserts an image into the list at the specified position.</p></ol>

<p>The format of the SetImageList method is:</p>

<pre class="code">
  unsigned int SetImageList(Image *images,const Image *image,
    const long offset,ExceptionInfo *exception)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>offset</h5>
<ol><p>The position within the list.</p></ol>

<h5>exception</h5>
<ol><p>Return any errors or warnings in this structure.</p></ol>

<div style="margin: auto;">
  <h2><a name="SetMonitorHandler">SetMonitorHandler</a></h2>
</div>

<p>SetMonitorHandler() sets the monitor handler to the specified method and returns the previous monitor handler.</p></ol>

<p>The format of the SetMonitorHandler method is:</p>

<pre class="code">
  MonitorHandler SetMonitorHandler(MonitorHandler handler)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>handler</h5>
<ol><p>Specifies a pointer to a method to handle monitors.</p></ol>

<div style="margin: auto;">
  <h2><a name="ShiftImageList">ShiftImageList</a></h2>
</div>

<p>ShiftImageList() removes an image from the beginning of the list.</p></ol>

<p>The format of the ShiftImageList method is:</p>

<pre class="code">
  Image *ShiftImageList(Image **images)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<div style="margin: auto;">
  <h2><a name="SpliceImageList">SpliceImageList</a></h2>
</div>

<p>SpliceImageList() removes the images designated by offset and length from the list and replaces them with the specified list.</p></ol>

<p>The format of the SpliceImageList method is:</p>

<pre class="code">
  Image *SpliceImageList(Image *images,const long offset,
    const unsigned long length,const Image *splices,
    ExceptionInfo *exception)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<h5>offset</h5>
<ol><p>The position within the list.</p></ol>

<h5>length</h5>
<ol><p>The length of the image list to remove.</p></ol>

<h5>splice</h5>
<ol><p>Replace the removed image list with this list.</p></ol>

<h5>exception</h5>
<ol><p>Return any errors or warnings in this structure.</p></ol>

<div style="margin: auto;">
  <h2><a name="Strip">Strip</a></h2>
</div>

<p>Strip() strips any whitespace or quotes from the beginning and end of a string of characters.</p></ol>

<p>The format of the Strip method is:</p>

<pre class="code">
  void Strip(char *message)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>message</h5>
<ol><p>Specifies an array of characters.</p></ol>

<div style="margin: auto;">
  <h2><a name="TemporaryFilename">TemporaryFilename</a></h2>
</div>

<p>TemporaryFilename() replaces the contents of path by a unique path name.</p></ol>

<p>The format of the TemporaryFilename method is:</p>

<pre class="code">
  void TemporaryFilename(char *path)
</pre>

<p>A description of each parameter follows.</p></ol>

<h5> path</h5>
<ol><p>Specifies a pointer to an array of characters.  The unique path name is returned in this array.</p></ol>

<div style="margin: auto;">
  <h2><a name="ThresholdImage">ThresholdImage</a></h2>
</div>

<p>ThresholdImage() changes the value of individual pixels based on the intensity of each pixel compared to threshold.  The result is a high-contrast, two color image.</p></ol>

<p>The format of the ThresholdImage method is:</p>

<pre class="code">
  unsigned int ThresholdImage(Image *image,const double threshold)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>threshold</h5>
<ol><p>Define the threshold value</p></ol>

<div style="margin: auto;">
  <h2><a name="ThresholdImageChannel">ThresholdImageChannel</a></h2>
</div>

<p>ThresholdImageChannel() changes the value of individual pixels based on the intensity of each pixel channel.  The result is a high-contrast image.</p></ol>

<p>The format of the ThresholdImageChannel method is:</p>

<pre class="code">
  unsigned int ThresholdImageChannel(Image *image,const char *threshold)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>threshold</h5>
<ol><p>define the threshold values.</p></ol>

<div style="margin: auto;">
  <h2><a name="TranslateText">TranslateText</a></h2>
</div>

<p>TranslateText() replaces any embedded formatting characters with the appropriate image attribute and returns the translated text.</p></ol>

<p>The format of the TranslateText method is:</p>

<pre class="code">
  char *TranslateText(const ImageInfo *image_info,Image *image,
    const char *embed_text)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image_info</h5>
<ol><p>The image info.</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>embed_text</h5>
<ol><p>The address of a character string containing the embedded formatting characters.</p></ol>

<div style="margin: auto;">
  <h2><a name="TransparentImage">TransparentImage</a></h2>
</div>

<p>TransparentImage() changes the opacity value associated with any pixel that matches color to the value defined by opacity.</p></ol>

<p>By default color must match a particular pixel color exactly.  However, in many cases two colors may differ by a small amount.  Fuzz defines how much tolerance is acceptable to consider two colors as the same. For example, set fuzz to 10 and the color red at intensities of 100 and 102 respectively are now interpreted as the same color.</p></ol>

<p>The format of the TransparentImage method is:</p>

<pre class="code">
  MagickBooleanType TransparentImage(Image *image,
    const PixelPacket target,const Quantum opacity)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>target</h5>
<ol><p>The RGB value of the target color.</p></ol>

<h5>opacity</h5>
<ol><p>The replacement opacity value.</p></ol>

<div style="margin: auto;">
  <h2><a name="UnshiftImageList">UnshiftImageList</a></h2>
</div>

<p>UnshiftImageList() adds the image to the beginning of the list.</p></ol>

<p>The format of the UnshiftImageList method is:</p>

<pre class="code">
  unsigned int UnshiftImageList(Image *images,const Image *image,
    ExceptionInfo *exception)
</pre>

<p>A description of each parameter follows:</p></ol>

<h5>images</h5>
<ol><p>The image list.</p></ol>

<h5>image</h5>
<ol><p>The image.</p></ol>

<h5>exception</h5>
<ol><p>Return any errors or warnings in this structure.</p></ol>

      </td>
      <td id="margin" width="1%" height="100%" valign="top" align="right">&nbsp;</td>
    </tr>
  </tbody>
  </table>
  <div id="linkbar">
    <a href="http://www.imagemagick.org/discourse-server" target="324779808">Discourse Server</a> &bull;
    <a href="../../www/mailing-list.html">Mailing Lists</a> &bull;
    <a href="http://studio.webbyland.com/ImageMagick/MagickStudio/scripts/MagickStudio.cgi" target="245345784">ImageMagick Studio</a>
  </div>
  <div id="footer">
    <span id="footer-west">&copy; 1999-2007 ImageMagick Studio LLC</span>
  </div>
  <div style="clear: both; margin: 0; width: 100%; "></div>
</body>
</html>
